1) JVM-level SSL handshake (most detailed)

Add SSL debug to Liberty’s JVM options (affects all SSL, including Db2):

<jvmOptions>
  -Djavax.net.debug=ssl:handshake:keymanager:trustmanager
  <!-- Optional extras when you’re stuck:
       -Djavax.net.debug=ssl:handshake:verbose
       -Djavax.net.debug=all  (very noisy) -->
</jvmOptions>


Where to look / what to grep:

ClientHello → check TLSv1.2 and the offered cipher suites

ServerHello → which protocol/cipher was selected

certificate chain details, trust decisions, and any alert: handshake_failure

2) Liberty component trace (channels, SSL, JDBC/JCA)

Turn on focused Liberty tracing so you see the connection lifecycle around the handshake and JDBC resource use:

<logging
  traceSpecification="
    com.ibm.ws.ssl.*=all:
    com.ibm.ws.channel.ssl.*=all:
    com.ibm.ws.tcpchannel.*=all:
    com.ibm.ws.jca.*=all:
    com.ibm.ws.rsadapter.*=all:
    com.ibm.ws.jdbc.*=all"
/>


Tip: you can temporarily add com.ibm.ws.logging.*=all to confirm file roll-over and sizes.

3) Db2 JCC driver trace (driver-internal view)

Enable the JCC trace on the datasource so you capture the driver’s own SSL/TLS settings and connect flow.

A. Put trace to a specific file:

<dataSource jndiName="jdbc/DB2TLS" jdbcDriverRef="db2Lib">
  <properties.db2.jcc
      databaseName="${env.DBNAME}"
      serverName="${env.DBHOST}"
      portNumber="${env.DBPORT_SECURE}"
      sslConnection="true"
      <!-- pin version if needed -->
      sslVersion="TLSv1.2"
      <!-- JCC trace controls -->
      traceFile="${server.output.dir}/logs/jcc-db2-trace.log"
      traceFileAppend="true"
      traceLevel="TRACE_ALL"/>
</dataSource>


B. Or use a directory + rotating files:

<properties.db2.jcc
    ...
    traceDirectory="${server.output.dir}/logs/jcc"
    traceFile="db2jcc"
    traceFileAppend="true"
    traceLevel="TRACE_ALL"/>


Notes:

If Liberty warns about an unknown vendor property in the properties.db2.jcc block, move it to a generic block:

<properties traceDirectory="..." traceFile="db2jcc" traceLevel="TRACE_ALL"/>


Common values for traceLevel include TRACE_ALL (max) and TRACE_NONE.

4) Narrowing scope to just this datasource (optional)

If logs are too noisy, isolate by running a tiny servlet/REST endpoint that does a single lookup + getConnection() and then disable global SSL traffic during the test window.

5) What “good” looks like

From JVM SSL debug:

You should see ClientHello, TLSv1.2 and then ServerHello, TLSv1.2.

Selected cipher should be one both sides support (e.g., TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384).

Chain validation: look for *** Certificate chain and ... trustmanager ... checking ... OK.

From JCC trace:

sslConnection=true, optional sslVersion=TLSv1.2

Any explicit trust or keystore paths you set (e.g., sslTrustStoreLocation) echoed back

If client-cert auth is in play, you’ll see the client keystore load and securityMechanism=18.

6) Quick triage patterns

handshake alert: handshake_failure → protocol/cipher mismatch or trust issue.

Client offers TLS1.2 but server replies TLS1.1 → fix server AT-TLS/DDF policy or pin sslVersion="TLSv1.2" and ensure JVM disables TLS1.1.

unable to find valid certification path → truststore missing server CA (use Liberty keystore or JCC sslTrustStoreLocation).

7) Clean up

Once you’ve captured what you need, remove or relax:

-Djavax.net.debug (it’s very verbose)

High-volume Liberty trace specs

JCC trace* properties

If you paste your current <dataSource> and <logging>/<jvmOptions> snippets, I’ll mark exactly where to add these and suggest the minimal set to reproduce the handshake.

ChatGPT can make mistakes. Ch

#####################################################################

Save as /opt/liberty/sec/java.security.tls12 (any readable path is fine):

# --- Force TLS 1.2 only by disabling others ---
# Disables TLSv1, TLSv1.1, and TLSv1.3 so only TLSv1.2 remains enabled.
jdk.tls.disabledAlgorithms=SSLv2Hello, SSLv3, TLSv1, TLSv1.1, TLSv1.3, \
  RC4, DES, 3DES, DESede, MD5withRSA, \
  NULL, anon, EXPORT, \
  DH keySize < 2048, RSA keySize < 2048, DSA keySize < 2048, EC keySize < 224, \
  CBC

# Harden certificate path validation (optional but recommended)
jdk.certpath.disabledAlgorithms=MD2, MD5, \
  SHA1 jdkCA & usage TLSServer, \
  RSA keySize < 2048, DSA keySize < 2048, EC keySize < 224

# (Optional) default keystore type
# keystore.type=PKCS12


Notes:

Adding CBC disables CBC-mode cipher suites, nudging the JVM to prefer AES-GCM suites (e.g., TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256).

If your environment still needs CBC suites, remove CBC from the list.

2) Tell Liberty to use it

Add ONE of these lines to <server.config.dir>/jvm.options (absolute path; no ${…} expansion here):

Append / override (recommended):

-Djava.security.properties=/opt/liberty/sec/java.security.tls12


Replace the default file entirely (advanced):

-Djava.security.properties==/opt/liberty/sec/java.security.tls12


(Use the single = form unless you’ve copied all defaults into your custom file.)

3) (Optional) Pin client side explicitly

Some apps/libraries choose TLS protocol programmatically. To be extra explicit for outbound TLS:

-Djdk.tls.client.protocols=TLSv1.2

4) Restart and verify

Restart Liberty.

Verify an HTTPS port only negotiates TLS 1.2:

openssl s_client -connect host:9443 -tls1_2 -brief
# should succeed
openssl s_client -connect host:9443 -tls1_3 -brief
# should FAIL (protocol disabled)


For JDBC/DB2 handshakes, you can temporarily add:

-Djavax.net.debug=ssl,handshake


and check messages.log for TLSv1.2 and GCM suites.

5) Heads-up / rollback

Disabling TLS 1.3 affects all SSL in this JVM (Liberty endpoints, clients, drivers). Ensure all peers support TLS 1.2.

To roll back, remove the -Djava.security.properties… line and restart.

If you also want Liberty’s own endpoints to be explicitly pinned (in addition to JVM hardening), set sslProtocol="TLSv1.2" on your <ssl> and reference it via sslRef on each endpoint. I can show that snippet too if you’d like.




2) Java program (if you have Liberty running)

Create a tiny Java snippet to load the class and print the version:

import com.ibm.db2.jcc.DB2Driver;
public class CheckDB2DriverVersion {
    public static void main(String[] args) {
        System.out.println("DB2 JDBC Driver Version: " + DB2Driver.getVersion());
    }
}


Compile and run:

javac -cp db2jcc4.jar:. CheckDB2DriverVersion.java
java -cp db2jcc4.jar:. CheckDB2DriverVersion

3) Liberty startup logs

If the driver jar is in your <library> and Liberty loads it, the messages.log may show the version at startup:

CWWKC0001I: JDBC driver db2jcc4.jar version 4.27.42 loaded


If you don’t see it, temporarily enable JDBC trace:

<logging traceSpecification="com.ibm.ws.jdbc.*=all"/>


Then restart Liberty and check messages.log.

4) File name or path

Sometimes the version is embedded in the jar name:

db2jcc4-11.5.8.0.jar → DB2 driver v11.5.8.0 (Type 4)

db2jcc4.jar → must check manifest or logs, name alone doesn’t guarantee version.

Recommended versions for TLS 1.2 + sslTrustStoreType

DB2 11.1 / 11.5 → db2jcc4.jar version 4.21+ supports sslTrustStoreType.

For older DB2 LUW (10.5 or earlier), TLS 1.2 support starts in 3.71+.

If you share the Liberty folder path where your db2jcc*.jar lives, I can give you the exact command for your OS to print the version quickly.

Do you want me to give you a one-liner to check on Linux or Windows?


<dataSource id="Db2DS" jndiName="jdbc/test">
    <jdbcDriver libraryRef="db2-jdbc-lib"/>
    <properties.db2
        serverName="db2-host"
        portNumber="50001"
        databaseName="DBNAME"
        sslConnection="true"
        sslVersion="TLSv1.2"
        sslTrustStoreLocation="${server.config.dir}/security/db2trust.p12"
        sslTrustStorePassword="changeit"
        sslTrustStoreType="PKCS12"/>
</dataSource>


<iiopEndpoint id="defaultIiopEndpoint" host="*" iiopPort="2809">
  <iiopsOptions iiopsPort="9402" sslRef="defaultSSLConfig"/>
</iiopEndpoint>

-Xtrace:methods={com.example.ws.MyServiceImpl.*},print=mt
<logging traceSpecification="
  *=info:
  com.ibm.ws.webcontainer.*=all:
  com.ibm.ws.websvcs.*=all:
  com.ibm.ws.jaxws.*=all:
  com.ibm.ws.classloading.*=all:
  com.ibm.ws.naming.*=all"/>


<server>
  <!-- (Optional) ensure expansion -->
  <applicationManager autoExpand="true"/>

  <application id="Orders"  name="Orders"  location="apps/Orders.ear"  type="ear"/>
  <application id="Billing" name="Billing" location="apps/Billing.ear" type="ear"/>
</server>


<application id="MyApp" location="MyApp.ear" type="ear">
  <application-bnd>
    <security-role name="Admin">
      <group name="was-admins"/>
    </security-role>

    <security-role name="User">
      <group name="app-users"/>
      <group name="partners"/>
    </security-role>
  </application-bnd>
</application>



<application id="MyApp" location="MyApp.ear" type="ear">
  <application-bnd>

    <!-- Admin role: specific users -->
    <security-role name="Admin">
      <user name="ajay"/>
      <user name="john.doe"/>
      <user name="jane.smith"/>
    </security-role>

    <!-- Editor role: entire LDAP groups -->
    <security-role name="Editor">
      <group name="editors"/>
      <group name="content-team"/>
    </security-role>

    <!-- Viewer role: all authenticated users -->
    <security-role name="Viewer">
      <special-subject type="ALL_AUTHENTICATED_USERS"/>
    </security-role>

  </application-bnd>
</application>


<server>
  <featureManager>
    <!-- Web -->
    <feature>servlet-5.0</feature>
    <feature>jsp-3.0</feature>

    <!-- Core app infra -->
    <feature>jndi-1.0</feature>
    <feature>transaction-1.3</feature>
    <feature>cdi-4.0</feature>

    <!-- Persistence -->
    <feature>jdbc-4.3</feature>
    <feature>jpa-2.2</feature>

    <!-- Messaging -->
    <feature>jms-2.0</feature>
    <feature>wmqJmsClient-2.0</feature>   <!-- only if you use IBM MQ -->

    <!-- REST / JSON -->
    <feature>jaxrs-2.1</feature>
    <feature>jsonb-2.0</feature>
    <feature>jsonp-2.0</feature>

    <!-- EJB / MDB -->
    <feature>ejbLite-3.2</feature>

    <!-- Security -->
    <feature>appSecurity-3.0</feature>
    <feature>ldapRegistry-3.0</feature>
    <feature>ssl-2.0</feature>

    <!-- Extras (enable if you use them) -->
    <!-- <feature>concurrent-1.0</feature> -->
    <!-- <feature>mail-1.6</feature> -->
    <!-- <feature>websocket-2.0</feature> -->
    <!-- <feature>batch-2.1</feature> -->

    <!-- Ops -->
    <!-- <feature>mpHealth-3.1</feature> -->
    <!-- <feature>mpMetrics-5.0</feature> -->
  </featureManager>
</server>

