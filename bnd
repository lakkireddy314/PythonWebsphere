<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://xmlns.jcp.org/xml/ns/javaee"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://www.oracle.com/webfolder/technetwork/jsc/xml/ns/javaee/beans_1_1.xsd"
   bean-discovery-mode="none">
</beans>

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://xmlns.jcp.org/xml/ns/javaee"
       version="2.0"
       bean-discovery-mode="annotated">
  <scan>
    <!-- skip the offending interceptor(s) -->
    <exclude name="com.yourco.problem.**"/>
    <!-- or: <exclude name="com.yourco.problem.InitInterceptor"/> -->
  </scan>
</beans>




<persistence xmlns="http://java.sun.com/xml/ns/persistence" version="2.0">
  <persistence-unit name="MyPU" transaction-type="JTA">
    <!-- Let the container supply the DataSource -->
    <jta-data-source>jdbc/DB2XA</jta-data-source>
    <!-- If you bundle Hibernate, it will be the provider; you can be explicit: -->
    <!-- <provider>org.hibernate.ejb.HibernatePersistence</provider> -->
    <properties>
      <!-- Hibernate/JPA options you need -->
      <property name="hibernate.dialect" value="org.hibernate.dialect.DB2Dialect"/>
      <property name="hibernate.show_sql" value="false"/>
      <property name="hibernate.format_sql" value="true"/>
      <!-- Ensure JTA integration -->
      <property name="hibernate.transaction.factory_class"
                value="org.hibernate.transaction.JTATransactionFactory"/>
      <property name="hibernate.transaction.jta.platform"
                value="org.hibernate.service.jta.platform.internal.SunOneJtaPlatform"/>
      <!-- Adjust the jta.platform if you have a specific Liberty adapter; many apps work with default -->
    </properties>
  </persistence-unit>
</persistence>





<!-- WEB-INF/classes/log4j2.xml -->
<Configuration status="WARN">
  <Appenders>
    <Console name="CONSOLE" target="SYSTEM_OUT">
      <PatternLayout pattern="%d{HH:mm:ss.SSS} %-5p [%t] %c - %m%n"/>
    </Console>
    <!-- optional rolling file -->
    <RollingFile name="FILE" fileName="${sys:catalina.base:-.}/logs/app.log"
                 filePattern="${sys:catalina.base:-.}/logs/app-%d{yyyy-MM-dd}-%i.log.gz">
      <PatternLayout pattern="%d{yyyy-MM-dd HH:mm:ss.SSS} %-5p [%t] %c - %m%n"/>
      <Policies>
        <TimeBasedTriggeringPolicy/>
        <SizeBasedTriggeringPolicy size="20 MB"/>
      </Policies>
      <DefaultRolloverStrategy max="10"/>
    </RollingFile>
  </Appenders>

  <Loggers>
    <!-- SQL text -->
    <Logger name="org.hibernate.SQL" level="debug" additivity="false">
      <AppenderRef ref="CONSOLE"/>
      <AppenderRef ref="FILE"/>
    </Logger>

    <!-- Bind values: pick ONE depending on Hibernate version -->
    <!-- Hibernate 5.x -->
    <Logger name="org.hibernate.type.descriptor.sql" level="trace" additivity="false">
      <AppenderRef ref="CONSOLE"/>
      <AppenderRef ref="FILE"/>
    </Logger>
    <!-- Hibernate 6.x (uncomment and use instead of the 5.x line)
    <Logger name="org.hibernate.orm.jdbc.bind" level="trace" additivity="false">
      <AppenderRef ref="CONSOLE"/>
      <AppenderRef ref="FILE"/>
    </Logger>
    -->

    <!-- Tx lifecycle & exception details -->
    <Logger name="org.hibernate.engine.transaction" level="debug"/>
    <Logger name="org.hibernate.resource.transaction" level="debug"/>
    <Logger name="org.hibernate.engine.jdbc.spi.SqlExceptionHelper" level="debug"/>

    <!-- Optional: JPA container glue (useful on Liberty) -->
    <Logger name="org.hibernate.jpa" level="debug"/>

    <Root level="info">
      <AppenderRef ref="CONSOLE"/>
      <AppenderRef ref="FILE"/>
    </Root>
  </Loggers>
</Configuration>



1) Enable Liberty trace for Hibernate + JDBC + Tx

Add this to server.xml inside <server>:

<logging traceSpecification="
  org.hibernate.*=all:
  org.jboss.logging.*=all:
  com.ibm.ws.jpa.*=all:
  com.ibm.ws.rsadapter.*=all:
  com.ibm.ws.jdbc.*=all:
  com.ibm.db2.jcc.*=finest:
  com.ibm.ws.jndi.*=all:
  com.ibm.ws.transaction.*=all
" consoleLogLevel="INFO" maxFileSize="20" maxFiles="5" traceFormat="BASIC"/>


org.hibernate.*=all → Hibernate internals

com.ibm.ws.transaction.*=all → Liberty transaction manager details

com.ibm.ws.jpa.*=all → JPA/Hibernate container integration

com.ibm.ws.jdbc.*=all, com.ibm.db2.jcc.*=finest → JDBC + Db2 driver layer

com.ibm.ws.jndi.*=all → JNDI lookups (for DataSource binding issues)

Trace output goes to logs/trace.log under your server directory.

2) Turn on Hibernate SQL + bind logging

If you use JPA/Hibernate with Log4j/SLF4J inside the app, add to persistence.xml or hibernate.properties:

hibernate.show_sql=true
hibernate.format_sql=true
hibernate.type.descriptor.sql.BasicBinder=TRACE
hibernate.generate_statistics=true


And in your logger config (e.g., log4j2.xml or logback.xml):

org.hibernate.SQL=DEBUG
org.hibernate.type.descriptor.sql=TRACE
org.hibernate.engine.transaction=DEBUG
org.hibernate.resource.transaction=DEBUG
org.hibernate.engine.jdbc.spi.SqlExceptionHelper=DEBUG


This shows:

The SQL text

The parameter values being bound

Transaction boundaries (begin/commit/rollback)

3) Restart the server

After you save server.xml, restart Liberty.
Look for trace.log under wlp/usr/servers/<servername>/logs/.

Search for org.hibernate to see SQL/binds

Search for com.ibm.ws.transaction to see transaction enlistment

Search for com.ibm.db2.jcc to see DB2 driver calls

4) Typical trace flow you should see

JNDI lookup of jdbc/cla via com.ibm.ws.jndi.*

Connection acquisition via com.ibm.ws.rsadapter.*

Hibernate transaction begin (org.hibernate.engine.transaction)

SQL prepare + bind (org.hibernate.SQL + BasicBinder)

Commit/Rollback (com.ibm.ws.transaction.*)

If something fails, the trace line right before the exception usually shows the root cause.

I can give you a copy-paste traceSpecification that includes only Hibernate + JDBC + Tx (no noisy subsystems) so you don’t drown in logs.

Do you want me to prepare that minimal trace config?


1) JVM-level SSL handshake (most detailed)

Add SSL debug to Liberty’s JVM options (affects all SSL, including Db2):

<jvmOptions>
  -Djavax.net.debug=ssl:handshake:keymanager:trustmanager
  <!-- Optional extras when you’re stuck:
       -Djavax.net.debug=ssl:handshake:verbose
       -Djavax.net.debug=all  (very noisy) -->
</jvmOptions>


Where to look / what to grep:

ClientHello → check TLSv1.2 and the offered cipher suites

ServerHello → which protocol/cipher was selected

certificate chain details, trust decisions, and any alert: handshake_failure

2) Liberty component trace (channels, SSL, JDBC/JCA)

Turn on focused Liberty tracing so you see the connection lifecycle around the handshake and JDBC resource use:

<logging
  traceSpecification="
    com.ibm.ws.ssl.*=all:
    com.ibm.ws.channel.ssl.*=all:
    com.ibm.ws.tcpchannel.*=all:
    com.ibm.ws.jca.*=all:
    com.ibm.ws.rsadapter.*=all:
    com.ibm.ws.jdbc.*=all"
/>


Tip: you can temporarily add com.ibm.ws.logging.*=all to confirm file roll-over and sizes.

3) Db2 JCC driver trace (driver-internal view)

Enable the JCC trace on the datasource so you capture the driver’s own SSL/TLS settings and connect flow.

A. Put trace to a specific file:

<dataSource jndiName="jdbc/DB2TLS" jdbcDriverRef="db2Lib">
  <properties.db2.jcc
      databaseName="${env.DBNAME}"
      serverName="${env.DBHOST}"
      portNumber="${env.DBPORT_SECURE}"
      sslConnection="true"
      <!-- pin version if needed -->
      sslVersion="TLSv1.2"
      <!-- JCC trace controls -->
      traceFile="${server.output.dir}/logs/jcc-db2-trace.log"
      traceFileAppend="true"
      traceLevel="TRACE_ALL"/>
</dataSource>


B. Or use a directory + rotating files:

<properties.db2.jcc
    ...
    traceDirectory="${server.output.dir}/logs/jcc"
    traceFile="db2jcc"
    traceFileAppend="true"
    traceLevel="TRACE_ALL"/>


Notes:

If Liberty warns about an unknown vendor property in the properties.db2.jcc block, move it to a generic block:

<properties traceDirectory="..." traceFile="db2jcc" traceLevel="TRACE_ALL"/>


Common values for traceLevel include TRACE_ALL (max) and TRACE_NONE.

4) Narrowing scope to just this datasource (optional)

If logs are too noisy, isolate by running a tiny servlet/REST endpoint that does a single lookup + getConnection() and then disable global SSL traffic during the test window.

5) What “good” looks like

From JVM SSL debug:

You should see ClientHello, TLSv1.2 and then ServerHello, TLSv1.2.

Selected cipher should be one both sides support (e.g., TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384).

Chain validation: look for *** Certificate chain and ... trustmanager ... checking ... OK.

From JCC trace:

sslConnection=true, optional sslVersion=TLSv1.2

Any explicit trust or keystore paths you set (e.g., sslTrustStoreLocation) echoed back

If client-cert auth is in play, you’ll see the client keystore load and securityMechanism=18.

6) Quick triage patterns

handshake alert: handshake_failure → protocol/cipher mismatch or trust issue.

Client offers TLS1.2 but server replies TLS1.1 → fix server AT-TLS/DDF policy or pin sslVersion="TLSv1.2" and ensure JVM disables TLS1.1.

unable to find valid certification path → truststore missing server CA (use Liberty keystore or JCC sslTrustStoreLocation).

7) Clean up

Once you’ve captured what you need, remove or relax:

-Djavax.net.debug (it’s very verbose)

High-volume Liberty trace specs

JCC trace* properties

If you paste your current <dataSource> and <logging>/<jvmOptions> snippets, I’ll mark exactly where to add these and suggest the minimal set to reproduce the handshake.

ChatGPT can make mistakes. Ch

#####################################################################

Save as /opt/liberty/sec/java.security.tls12 (any readable path is fine):

# --- Force TLS 1.2 only by disabling others ---
# Disables TLSv1, TLSv1.1, and TLSv1.3 so only TLSv1.2 remains enabled.
jdk.tls.disabledAlgorithms=SSLv2Hello, SSLv3, TLSv1, TLSv1.1, TLSv1.3, \
  RC4, DES, 3DES, DESede, MD5withRSA, \
  NULL, anon, EXPORT, \
  DH keySize < 2048, RSA keySize < 2048, DSA keySize < 2048, EC keySize < 224, \
  CBC

# Harden certificate path validation (optional but recommended)
jdk.certpath.disabledAlgorithms=MD2, MD5, \
  SHA1 jdkCA & usage TLSServer, \
  RSA keySize < 2048, DSA keySize < 2048, EC keySize < 224

# (Optional) default keystore type
# keystore.type=PKCS12


Notes:

Adding CBC disables CBC-mode cipher suites, nudging the JVM to prefer AES-GCM suites (e.g., TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256).

If your environment still needs CBC suites, remove CBC from the list.

2) Tell Liberty to use it

Add ONE of these lines to <server.config.dir>/jvm.options (absolute path; no ${…} expansion here):

Append / override (recommended):

-Djava.security.properties=/opt/liberty/sec/java.security.tls12


Replace the default file entirely (advanced):

-Djava.security.properties==/opt/liberty/sec/java.security.tls12


(Use the single = form unless you’ve copied all defaults into your custom file.)

3) (Optional) Pin client side explicitly

Some apps/libraries choose TLS protocol programmatically. To be extra explicit for outbound TLS:

-Djdk.tls.client.protocols=TLSv1.2

4) Restart and verify

Restart Liberty.

Verify an HTTPS port only negotiates TLS 1.2:

openssl s_client -connect host:9443 -tls1_2 -brief
# should succeed
openssl s_client -connect host:9443 -tls1_3 -brief
# should FAIL (protocol disabled)


For JDBC/DB2 handshakes, you can temporarily add:

-Djavax.net.debug=ssl,handshake


and check messages.log for TLSv1.2 and GCM suites.

5) Heads-up / rollback

Disabling TLS 1.3 affects all SSL in this JVM (Liberty endpoints, clients, drivers). Ensure all peers support TLS 1.2.

To roll back, remove the -Djava.security.properties… line and restart.

If you also want Liberty’s own endpoints to be explicitly pinned (in addition to JVM hardening), set sslProtocol="TLSv1.2" on your <ssl> and reference it via sslRef on each endpoint. I can show that snippet too if you’d like.




2) Java program (if you have Liberty running)

Create a tiny Java snippet to load the class and print the version:

import com.ibm.db2.jcc.DB2Driver;
public class CheckDB2DriverVersion {
    public static void main(String[] args) {
        System.out.println("DB2 JDBC Driver Version: " + DB2Driver.getVersion());
    }
}


Compile and run:

javac -cp db2jcc4.jar:. CheckDB2DriverVersion.java
java -cp db2jcc4.jar:. CheckDB2DriverVersion

3) Liberty startup logs

If the driver jar is in your <library> and Liberty loads it, the messages.log may show the version at startup:

CWWKC0001I: JDBC driver db2jcc4.jar version 4.27.42 loaded


If you don’t see it, temporarily enable JDBC trace:

<logging traceSpecification="com.ibm.ws.jdbc.*=all"/>


Then restart Liberty and check messages.log.

4) File name or path

Sometimes the version is embedded in the jar name:

db2jcc4-11.5.8.0.jar → DB2 driver v11.5.8.0 (Type 4)

db2jcc4.jar → must check manifest or logs, name alone doesn’t guarantee version.

Recommended versions for TLS 1.2 + sslTrustStoreType

DB2 11.1 / 11.5 → db2jcc4.jar version 4.21+ supports sslTrustStoreType.

For older DB2 LUW (10.5 or earlier), TLS 1.2 support starts in 3.71+.

If you share the Liberty folder path where your db2jcc*.jar lives, I can give you the exact command for your OS to print the version quickly.

Do you want me to give you a one-liner to check on Linux or Windows?


<dataSource id="Db2DS" jndiName="jdbc/test">
    <jdbcDriver libraryRef="db2-jdbc-lib"/>
    <properties.db2
        serverName="db2-host"
        portNumber="50001"
        databaseName="DBNAME"
        sslConnection="true"
        sslVersion="TLSv1.2"
        sslTrustStoreLocation="${server.config.dir}/security/db2trust.p12"
        sslTrustStorePassword="changeit"
        sslTrustStoreType="PKCS12"/>
</dataSource>


<iiopEndpoint id="defaultIiopEndpoint" host="*" iiopPort="2809">
  <iiopsOptions iiopsPort="9402" sslRef="defaultSSLConfig"/>
</iiopEndpoint>

-Xtrace:methods={com.example.ws.MyServiceImpl.*},print=mt
<logging traceSpecification="
  *=info:
  com.ibm.ws.webcontainer.*=all:
  com.ibm.ws.websvcs.*=all:
  com.ibm.ws.jaxws.*=all:
  com.ibm.ws.classloading.*=all:
  com.ibm.ws.naming.*=all"/>


<server>
  <!-- (Optional) ensure expansion -->
  <applicationManager autoExpand="true"/>

  <application id="Orders"  name="Orders"  location="apps/Orders.ear"  type="ear"/>
  <application id="Billing" name="Billing" location="apps/Billing.ear" type="ear"/>
</server>


<application id="MyApp" location="MyApp.ear" type="ear">
  <application-bnd>
    <security-role name="Admin">
      <group name="was-admins"/>
    </security-role>

    <security-role name="User">
      <group name="app-users"/>
      <group name="partners"/>
    </security-role>
  </application-bnd>
</application>



<application id="MyApp" location="MyApp.ear" type="ear">
  <application-bnd>

    <!-- Admin role: specific users -->
    <security-role name="Admin">
      <user name="ajay"/>
      <user name="john.doe"/>
      <user name="jane.smith"/>
    </security-role>

    <!-- Editor role: entire LDAP groups -->
    <security-role name="Editor">
      <group name="editors"/>
      <group name="content-team"/>
    </security-role>

    <!-- Viewer role: all authenticated users -->
    <security-role name="Viewer">
      <special-subject type="ALL_AUTHENTICATED_USERS"/>
    </security-role>

  </application-bnd>
</application>


<server>
  <featureManager>
    <!-- Web -->
    <feature>servlet-5.0</feature>
    <feature>jsp-3.0</feature>

    <!-- Core app infra -->
    <feature>jndi-1.0</feature>
    <feature>transaction-1.3</feature>
    <feature>cdi-4.0</feature>

    <!-- Persistence -->
    <feature>jdbc-4.3</feature>
    <feature>jpa-2.2</feature>

    <!-- Messaging -->
    <feature>jms-2.0</feature>
    <feature>wmqJmsClient-2.0</feature>   <!-- only if you use IBM MQ -->

    <!-- REST / JSON -->
    <feature>jaxrs-2.1</feature>
    <feature>jsonb-2.0</feature>
    <feature>jsonp-2.0</feature>

    <!-- EJB / MDB -->
    <feature>ejbLite-3.2</feature>

    <!-- Security -->
    <feature>appSecurity-3.0</feature>
    <feature>ldapRegistry-3.0</feature>
    <feature>ssl-2.0</feature>

    <!-- Extras (enable if you use them) -->
    <!-- <feature>concurrent-1.0</feature> -->
    <!-- <feature>mail-1.6</feature> -->
    <!-- <feature>websocket-2.0</feature> -->
    <!-- <feature>batch-2.1</feature> -->

    <!-- Ops -->
    <!-- <feature>mpHealth-3.1</feature> -->
    <!-- <feature>mpMetrics-5.0</feature> -->
  </featureManager>
</server>

