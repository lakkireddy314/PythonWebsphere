<logging traceFileName="trace.log"
         traceSpecification="*=info:
                             com.ibm.ws.webcontainer.*=all:
                             com.ibm.ws.jsp.*=all:
                             com.ibm.ws.classloader.*=all:
                             com.ibm.ws.injection.*=all:
                             com.ibm.ws.cdi.*=all:
                             org.jboss.weld.*=all:
                             com.ibm.ws.jaxws.*=all"/>


4) Eliminate JAX-WS impl conflicts

Don’t bundle Metro/CXF or javax.xml.ws impl jars if you’re using Liberty’s JAX-WS. They can clash with Liberty’s injection/creation. If you must use a 3rd-party stack, follow IBM’s guidance to disable Liberty’s feature and load your impl locally. 
IBM

5) Turn on targeted trace to see the real cause

In server.xml:

<logging traceSpecification="
  com.ibm.ws.support.*=all:
  com.ibm.ws.jaxws.*=all:
  com.ibm.ws.webservices.*=all:
  com.ibm.wsspi.webcontainer.annotation.*=all:
  com.ibm.ws.injection.*=all:
  com.ibm.ws.ffdc=all"/>


Reproduce once, then check logs/ffdc/* and logs/trace.log for the first throwable—often a missing JNDI target, bad constructor, or an exception in @PostConstruct. 
IBM

Quick checklist to run now

Confirm jaxws-2.2 (+ servlet, + jaxb-2.2) are enabled. 
openliberty.io

Ensure the endpoint class is public, concrete, public no-arg ctor. 
Rollbar

Map every @Resource/@WebServiceRef/@EJB to real JNDI entries via server.xml + ibm-web-bnd.xml. 
IBM

Remove Metro/CXF jars unless you intentionally use them (or disable Liberty’s JAX-WS per IBM note). 
IBM

If you paste one endpoint class name and a sample of its annotations (@WebService, any @Resource fields), I’ll give you the exact server.xml/binding snippets to satisfy its injections and stop the InstantiationException.

You said:
Eliminate JAX-WS impl conflicts?
ChatGPT said:
Thought for 35s

Yep—this is a classic “app-bundled JAX-WS stack vs Liberty’s JAX-WS” clash. Here’s how to eliminate conflicts cleanly on Liberty.

1) Use Liberty’s JAX-WS/JAXB features (and nothing else)

In server.xml:

<featureManager>
  <feature>servlet-4.0</feature>     <!-- or servlet-3.1 on older levels -->
  <feature>jaxws-2.2</feature>
  <feature>jaxb-2.2</feature>
  <!-- add <feature>ejbLite-3.1</feature> if your endpoint is an EJB -->
</featureManager>


Liberty provides the JAX-WS implementation via jaxws-2.2 (and JAXB via jaxb-2.2). Don’t ship your own JAX-WS/JAXB impl when using these features. 
openliberty.io
+2
openliberty.io
+2

2) Prefer server classes over app copies

Make sure the app classloader prefers the parent (server) so ServiceLoader picks Liberty’s provider first:

<webApplication id="YourApp" location="YourApp.war" contextRoot="/yourapp">
  <classloader delegation="parentFirst"/>
</webApplication>


(Parent-first is the default in Liberty, but setting it explicitly helps if you experimented with alternatives.) 
openliberty.io
+1

3) Remove (or quarantine) conflicting jars from the app

Unpack your EAR/WAR and delete any of these from WEB-INF/lib/ or lib/:

Metro/Sun: jaxws-rt*.jar, jaxws-impl*.jar, com.sun.xml.ws*, policy*.jar

CXF: cxf-*.jar, wsdl4j*.jar, neethi*.jar, xmlschema*.jar

JAXB impls/APIs: jaxb-impl*.jar, jaxb-api*.jar

APIs duplicated under javax.xml.ws*, jakarta.xml.ws*

If you truly can’t delete them, move them to a privateLibrary and still keep delegation="parentFirst" so Liberty wins. (But best practice is not to bundle an alternate JAX-WS when using Liberty’s feature.) 
IBM

4) Kill provider overrides

Some third-party stacks include META-INF/services/javax.xml.ws.spi.Provider. If that file lives in your app libs, it can force the app’s provider. Removing those impl jars (step 3) plus parent-first classloading prevents the override; Liberty’s own provider will be used. (You can confirm by turning on JAX-WS trace; see step 6.) 
openliberty.io

5) If you intentionally want Metro/CXF instead (not typical)

Then do not enable <feature>jaxws-2.2</feature>, keep the app’s stack complete, and expect to support it yourself. Liberty docs show how to flip classloader delegation if you must override provided APIs, but IBM support guidance is to use Liberty features whenever possible. 
IBM

6) Verify which provider is active (trace)

Add temporary tracing:

<logging traceSpecification="
  com.ibm.ws.jaxws.*=all:
  com.ibm.ws.webservices.*=all:
  com.ibm.ws.support.*=all:
  com.ibm.ws.ffdc=all"/>


Reproduce once and inspect logs/trace.log / logs/ffdc/* for the chosen javax.xml.ws.spi.Provider and endpoint creation details. 
IBM

Quick checklist to run now

✅ jaxws-2.2 + jaxb-2.2 enabled. 
openliberty.io
+1

✅ delegation="parentFirst" (or just ensure you haven’t set parent-last). 
openliberty.io

✅ Remove cxf-*, jaxws-rt/impl, jaxb-*, or any javax.xml.ws/jakarta.xml.ws API jars from the app. 
IBM

✅ (If EJB endpoint) add ejbLite-3.1. 
IBM

Do these, and the JaxWsInstanceManager.createInstance(...) + AnnotationHelper.inject(...) failures caused by impl conflicts typically disappear. If an InstantiationException persists after cleanup, the root cause is usually in the endpoint itself (no public no-arg ctor, abstract class, or a failure inside @PostConstruct). Turn on the trace from step 6 and share the first FFDC stack if you want me to pinpoint that next.



<?xml version="1.0" encoding="UTF-8"?>
<beans
  xmlns="http://xmlns.jcp.org/xml/ns/javaee"
  xmlns:weld="http://jboss.org/schema/weld/beans"
  version="2.0"
  bean-discovery-mode="annotated">

  <weld:scan>
    <!-- Exclude exactly the classes that throw InstantiationException -->
    <weld:exclude name="com.yourco.pkg.ClassOne"/>
    <weld:exclude name="com.yourco.pkg.ClassTwo"/>
    <weld:exclude name="com.yourco.pkg.ClassThree"/>
    <weld:exclude name="com.yourco.pkg.ClassFour"/>
    <!-- or a package pattern: <weld:exclude name="com.yourco.badpkg.**"/> -->
  </weld:scan>
</beans>


<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://xmlns.jcp.org/xml/ns/javaee"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://www.oracle.com/webfolder/technetwork/jsc/xml/ns/javaee/beans_1_1.xsd"
   bean-discovery-mode="none">
</beans>

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://xmlns.jcp.org/xml/ns/javaee"
       version="2.0"
       bean-discovery-mode="annotated">
  <scan>
    <!-- skip the offending interceptor(s) -->
    <exclude name="com.yourco.problem.**"/>
    <!-- or: <exclude name="com.yourco.problem.InitInterceptor"/> -->
  </scan>
</beans>

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://xmlns.jcp.org/xml/ns/javaee"
       version="1.1"
       bean-discovery-mode="annotated"/>



<persistence xmlns="http://java.sun.com/xml/ns/persistence" version="2.0">
  <persistence-unit name="MyPU" transaction-type="JTA">
    <!-- Let the container supply the DataSource -->
    <jta-data-source>jdbc/DB2XA</jta-data-source>
    <!-- If you bundle Hibernate, it will be the provider; you can be explicit: -->
    <!-- <provider>org.hibernate.ejb.HibernatePersistence</provider> -->
    <properties>
      <!-- Hibernate/JPA options you need -->
      <property name="hibernate.dialect" value="org.hibernate.dialect.DB2Dialect"/>
      <property name="hibernate.show_sql" value="false"/>
      <property name="hibernate.format_sql" value="true"/>
      <!-- Ensure JTA integration -->
      <property name="hibernate.transaction.factory_class"
                value="org.hibernate.transaction.JTATransactionFactory"/>
      <property name="hibernate.transaction.jta.platform"
                value="org.hibernate.service.jta.platform.internal.SunOneJtaPlatform"/>
      <!-- Adjust the jta.platform if you have a specific Liberty adapter; many apps work with default -->
    </properties>
  </persistence-unit>
</persistence>





<!-- WEB-INF/classes/log4j2.xml -->
<Configuration status="WARN">
  <Appenders>
    <Console name="CONSOLE" target="SYSTEM_OUT">
      <PatternLayout pattern="%d{HH:mm:ss.SSS} %-5p [%t] %c - %m%n"/>
    </Console>
    <!-- optional rolling file -->
    <RollingFile name="FILE" fileName="${sys:catalina.base:-.}/logs/app.log"
                 filePattern="${sys:catalina.base:-.}/logs/app-%d{yyyy-MM-dd}-%i.log.gz">
      <PatternLayout pattern="%d{yyyy-MM-dd HH:mm:ss.SSS} %-5p [%t] %c - %m%n"/>
      <Policies>
        <TimeBasedTriggeringPolicy/>
        <SizeBasedTriggeringPolicy size="20 MB"/>
      </Policies>
      <DefaultRolloverStrategy max="10"/>
    </RollingFile>
  </Appenders>

  <Loggers>
    <!-- SQL text -->
    <Logger name="org.hibernate.SQL" level="debug" additivity="false">
      <AppenderRef ref="CONSOLE"/>
      <AppenderRef ref="FILE"/>
    </Logger>

    <!-- Bind values: pick ONE depending on Hibernate version -->
    <!-- Hibernate 5.x -->
    <Logger name="org.hibernate.type.descriptor.sql" level="trace" additivity="false">
      <AppenderRef ref="CONSOLE"/>
      <AppenderRef ref="FILE"/>
    </Logger>
    <!-- Hibernate 6.x (uncomment and use instead of the 5.x line)
    <Logger name="org.hibernate.orm.jdbc.bind" level="trace" additivity="false">
      <AppenderRef ref="CONSOLE"/>
      <AppenderRef ref="FILE"/>
    </Logger>
    -->

    <!-- Tx lifecycle & exception details -->
    <Logger name="org.hibernate.engine.transaction" level="debug"/>
    <Logger name="org.hibernate.resource.transaction" level="debug"/>
    <Logger name="org.hibernate.engine.jdbc.spi.SqlExceptionHelper" level="debug"/>

    <!-- Optional: JPA container glue (useful on Liberty) -->
    <Logger name="org.hibernate.jpa" level="debug"/>

    <Root level="info">
      <AppenderRef ref="CONSOLE"/>
      <AppenderRef ref="FILE"/>
    </Root>
  </Loggers>
</Configuration>



1) Enable Liberty trace for Hibernate + JDBC + Tx

Add this to server.xml inside <server>:

<logging traceSpecification="
  org.hibernate.*=all:
  org.jboss.logging.*=all:
  com.ibm.ws.jpa.*=all:
  com.ibm.ws.rsadapter.*=all:
  com.ibm.ws.jdbc.*=all:
  com.ibm.db2.jcc.*=finest:
  com.ibm.ws.jndi.*=all:
  com.ibm.ws.transaction.*=all
" consoleLogLevel="INFO" maxFileSize="20" maxFiles="5" traceFormat="BASIC"/>


org.hibernate.*=all → Hibernate internals

com.ibm.ws.transaction.*=all → Liberty transaction manager details

com.ibm.ws.jpa.*=all → JPA/Hibernate container integration

com.ibm.ws.jdbc.*=all, com.ibm.db2.jcc.*=finest → JDBC + Db2 driver layer

com.ibm.ws.jndi.*=all → JNDI lookups (for DataSource binding issues)

Trace output goes to logs/trace.log under your server directory.

2) Turn on Hibernate SQL + bind logging

If you use JPA/Hibernate with Log4j/SLF4J inside the app, add to persistence.xml or hibernate.properties:

hibernate.show_sql=true
hibernate.format_sql=true
hibernate.type.descriptor.sql.BasicBinder=TRACE
hibernate.generate_statistics=true


And in your logger config (e.g., log4j2.xml or logback.xml):

org.hibernate.SQL=DEBUG
org.hibernate.type.descriptor.sql=TRACE
org.hibernate.engine.transaction=DEBUG
org.hibernate.resource.transaction=DEBUG
org.hibernate.engine.jdbc.spi.SqlExceptionHelper=DEBUG


This shows:

The SQL text

The parameter values being bound

Transaction boundaries (begin/commit/rollback)

3) Restart the server

After you save server.xml, restart Liberty.
Look for trace.log under wlp/usr/servers/<servername>/logs/.

Search for org.hibernate to see SQL/binds

Search for com.ibm.ws.transaction to see transaction enlistment

Search for com.ibm.db2.jcc to see DB2 driver calls

4) Typical trace flow you should see

JNDI lookup of jdbc/cla via com.ibm.ws.jndi.*

Connection acquisition via com.ibm.ws.rsadapter.*

Hibernate transaction begin (org.hibernate.engine.transaction)

SQL prepare + bind (org.hibernate.SQL + BasicBinder)

Commit/Rollback (com.ibm.ws.transaction.*)

If something fails, the trace line right before the exception usually shows the root cause.

I can give you a copy-paste traceSpecification that includes only Hibernate + JDBC + Tx (no noisy subsystems) so you don’t drown in logs.

Do you want me to prepare that minimal trace config?


1) JVM-level SSL handshake (most detailed)

Add SSL debug to Liberty’s JVM options (affects all SSL, including Db2):

<jvmOptions>
  -Djavax.net.debug=ssl:handshake:keymanager:trustmanager
  <!-- Optional extras when you’re stuck:
       -Djavax.net.debug=ssl:handshake:verbose
       -Djavax.net.debug=all  (very noisy) -->
</jvmOptions>


Where to look / what to grep:

ClientHello → check TLSv1.2 and the offered cipher suites

ServerHello → which protocol/cipher was selected

certificate chain details, trust decisions, and any alert: handshake_failure

2) Liberty component trace (channels, SSL, JDBC/JCA)

Turn on focused Liberty tracing so you see the connection lifecycle around the handshake and JDBC resource use:

<logging
  traceSpecification="
    com.ibm.ws.ssl.*=all:
    com.ibm.ws.channel.ssl.*=all:
    com.ibm.ws.tcpchannel.*=all:
    com.ibm.ws.jca.*=all:
    com.ibm.ws.rsadapter.*=all:
    com.ibm.ws.jdbc.*=all"
/>


Tip: you can temporarily add com.ibm.ws.logging.*=all to confirm file roll-over and sizes.

3) Db2 JCC driver trace (driver-internal view)

Enable the JCC trace on the datasource so you capture the driver’s own SSL/TLS settings and connect flow.

A. Put trace to a specific file:

<dataSource jndiName="jdbc/DB2TLS" jdbcDriverRef="db2Lib">
  <properties.db2.jcc
      databaseName="${env.DBNAME}"
      serverName="${env.DBHOST}"
      portNumber="${env.DBPORT_SECURE}"
      sslConnection="true"
      <!-- pin version if needed -->
      sslVersion="TLSv1.2"
      <!-- JCC trace controls -->
      traceFile="${server.output.dir}/logs/jcc-db2-trace.log"
      traceFileAppend="true"
      traceLevel="TRACE_ALL"/>
</dataSource>


B. Or use a directory + rotating files:

<properties.db2.jcc
    ...
    traceDirectory="${server.output.dir}/logs/jcc"
    traceFile="db2jcc"
    traceFileAppend="true"
    traceLevel="TRACE_ALL"/>


Notes:

If Liberty warns about an unknown vendor property in the properties.db2.jcc block, move it to a generic block:

<properties traceDirectory="..." traceFile="db2jcc" traceLevel="TRACE_ALL"/>


Common values for traceLevel include TRACE_ALL (max) and TRACE_NONE.

4) Narrowing scope to just this datasource (optional)

If logs are too noisy, isolate by running a tiny servlet/REST endpoint that does a single lookup + getConnection() and then disable global SSL traffic during the test window.

5) What “good” looks like

From JVM SSL debug:

You should see ClientHello, TLSv1.2 and then ServerHello, TLSv1.2.

Selected cipher should be one both sides support (e.g., TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384).

Chain validation: look for *** Certificate chain and ... trustmanager ... checking ... OK.

From JCC trace:

sslConnection=true, optional sslVersion=TLSv1.2

Any explicit trust or keystore paths you set (e.g., sslTrustStoreLocation) echoed back

If client-cert auth is in play, you’ll see the client keystore load and securityMechanism=18.

6) Quick triage patterns

handshake alert: handshake_failure → protocol/cipher mismatch or trust issue.

Client offers TLS1.2 but server replies TLS1.1 → fix server AT-TLS/DDF policy or pin sslVersion="TLSv1.2" and ensure JVM disables TLS1.1.

unable to find valid certification path → truststore missing server CA (use Liberty keystore or JCC sslTrustStoreLocation).

7) Clean up

Once you’ve captured what you need, remove or relax:

-Djavax.net.debug (it’s very verbose)

High-volume Liberty trace specs

JCC trace* properties

If you paste your current <dataSource> and <logging>/<jvmOptions> snippets, I’ll mark exactly where to add these and suggest the minimal set to reproduce the handshake.

ChatGPT can make mistakes. Ch

#####################################################################

Save as /opt/liberty/sec/java.security.tls12 (any readable path is fine):

# --- Force TLS 1.2 only by disabling others ---
# Disables TLSv1, TLSv1.1, and TLSv1.3 so only TLSv1.2 remains enabled.
jdk.tls.disabledAlgorithms=SSLv2Hello, SSLv3, TLSv1, TLSv1.1, TLSv1.3, \
  RC4, DES, 3DES, DESede, MD5withRSA, \
  NULL, anon, EXPORT, \
  DH keySize < 2048, RSA keySize < 2048, DSA keySize < 2048, EC keySize < 224, \
  CBC

# Harden certificate path validation (optional but recommended)
jdk.certpath.disabledAlgorithms=MD2, MD5, \
  SHA1 jdkCA & usage TLSServer, \
  RSA keySize < 2048, DSA keySize < 2048, EC keySize < 224

# (Optional) default keystore type
# keystore.type=PKCS12


Notes:

Adding CBC disables CBC-mode cipher suites, nudging the JVM to prefer AES-GCM suites (e.g., TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256).

If your environment still needs CBC suites, remove CBC from the list.

2) Tell Liberty to use it

Add ONE of these lines to <server.config.dir>/jvm.options (absolute path; no ${…} expansion here):

Append / override (recommended):

-Djava.security.properties=/opt/liberty/sec/java.security.tls12


Replace the default file entirely (advanced):

-Djava.security.properties==/opt/liberty/sec/java.security.tls12


(Use the single = form unless you’ve copied all defaults into your custom file.)

3) (Optional) Pin client side explicitly

Some apps/libraries choose TLS protocol programmatically. To be extra explicit for outbound TLS:

-Djdk.tls.client.protocols=TLSv1.2

4) Restart and verify

Restart Liberty.

Verify an HTTPS port only negotiates TLS 1.2:

openssl s_client -connect host:9443 -tls1_2 -brief
# should succeed
openssl s_client -connect host:9443 -tls1_3 -brief
# should FAIL (protocol disabled)


For JDBC/DB2 handshakes, you can temporarily add:

-Djavax.net.debug=ssl,handshake


and check messages.log for TLSv1.2 and GCM suites.

5) Heads-up / rollback

Disabling TLS 1.3 affects all SSL in this JVM (Liberty endpoints, clients, drivers). Ensure all peers support TLS 1.2.

To roll back, remove the -Djava.security.properties… line and restart.

If you also want Liberty’s own endpoints to be explicitly pinned (in addition to JVM hardening), set sslProtocol="TLSv1.2" on your <ssl> and reference it via sslRef on each endpoint. I can show that snippet too if you’d like.




2) Java program (if you have Liberty running)

Create a tiny Java snippet to load the class and print the version:

import com.ibm.db2.jcc.DB2Driver;
public class CheckDB2DriverVersion {
    public static void main(String[] args) {
        System.out.println("DB2 JDBC Driver Version: " + DB2Driver.getVersion());
    }
}


Compile and run:

javac -cp db2jcc4.jar:. CheckDB2DriverVersion.java
java -cp db2jcc4.jar:. CheckDB2DriverVersion

3) Liberty startup logs

If the driver jar is in your <library> and Liberty loads it, the messages.log may show the version at startup:

CWWKC0001I: JDBC driver db2jcc4.jar version 4.27.42 loaded


If you don’t see it, temporarily enable JDBC trace:

<logging traceSpecification="com.ibm.ws.jdbc.*=all"/>


Then restart Liberty and check messages.log.

4) File name or path

Sometimes the version is embedded in the jar name:

db2jcc4-11.5.8.0.jar → DB2 driver v11.5.8.0 (Type 4)

db2jcc4.jar → must check manifest or logs, name alone doesn’t guarantee version.

Recommended versions for TLS 1.2 + sslTrustStoreType

DB2 11.1 / 11.5 → db2jcc4.jar version 4.21+ supports sslTrustStoreType.

For older DB2 LUW (10.5 or earlier), TLS 1.2 support starts in 3.71+.

If you share the Liberty folder path where your db2jcc*.jar lives, I can give you the exact command for your OS to print the version quickly.

Do you want me to give you a one-liner to check on Linux or Windows?


<dataSource id="Db2DS" jndiName="jdbc/test">
    <jdbcDriver libraryRef="db2-jdbc-lib"/>
    <properties.db2
        serverName="db2-host"
        portNumber="50001"
        databaseName="DBNAME"
        sslConnection="true"
        sslVersion="TLSv1.2"
        sslTrustStoreLocation="${server.config.dir}/security/db2trust.p12"
        sslTrustStorePassword="changeit"
        sslTrustStoreType="PKCS12"/>
</dataSource>


<iiopEndpoint id="defaultIiopEndpoint" host="*" iiopPort="2809">
  <iiopsOptions iiopsPort="9402" sslRef="defaultSSLConfig"/>
</iiopEndpoint>

-Xtrace:methods={com.example.ws.MyServiceImpl.*},print=mt
<logging traceSpecification="
  *=info:
  com.ibm.ws.webcontainer.*=all:
  com.ibm.ws.websvcs.*=all:
  com.ibm.ws.jaxws.*=all:
  com.ibm.ws.classloading.*=all:
  com.ibm.ws.naming.*=all"/>


<server>
  <!-- (Optional) ensure expansion -->
  <applicationManager autoExpand="true"/>

  <application id="Orders"  name="Orders"  location="apps/Orders.ear"  type="ear"/>
  <application id="Billing" name="Billing" location="apps/Billing.ear" type="ear"/>
</server>


<application id="MyApp" location="MyApp.ear" type="ear">
  <application-bnd>
    <security-role name="Admin">
      <group name="was-admins"/>
    </security-role>

    <security-role name="User">
      <group name="app-users"/>
      <group name="partners"/>
    </security-role>
  </application-bnd>
</application>



<application id="MyApp" location="MyApp.ear" type="ear">
  <application-bnd>

    <!-- Admin role: specific users -->
    <security-role name="Admin">
      <user name="ajay"/>
      <user name="john.doe"/>
      <user name="jane.smith"/>
    </security-role>

    <!-- Editor role: entire LDAP groups -->
    <security-role name="Editor">
      <group name="editors"/>
      <group name="content-team"/>
    </security-role>

    <!-- Viewer role: all authenticated users -->
    <security-role name="Viewer">
      <special-subject type="ALL_AUTHENTICATED_USERS"/>
    </security-role>

  </application-bnd>
</application>


<server>
  <featureManager>
    <!-- Web -->
    <feature>servlet-5.0</feature>
    <feature>jsp-3.0</feature>

    <!-- Core app infra -->
    <feature>jndi-1.0</feature>
    <feature>transaction-1.3</feature>
    <feature>cdi-4.0</feature>

    <!-- Persistence -->
    <feature>jdbc-4.3</feature>
    <feature>jpa-2.2</feature>

    <!-- Messaging -->
    <feature>jms-2.0</feature>
    <feature>wmqJmsClient-2.0</feature>   <!-- only if you use IBM MQ -->

    <!-- REST / JSON -->
    <feature>jaxrs-2.1</feature>
    <feature>jsonb-2.0</feature>
    <feature>jsonp-2.0</feature>

    <!-- EJB / MDB -->
    <feature>ejbLite-3.2</feature>

    <!-- Security -->
    <feature>appSecurity-3.0</feature>
    <feature>ldapRegistry-3.0</feature>
    <feature>ssl-2.0</feature>

    <!-- Extras (enable if you use them) -->
    <!-- <feature>concurrent-1.0</feature> -->
    <!-- <feature>mail-1.6</feature> -->
    <!-- <feature>websocket-2.0</feature> -->
    <!-- <feature>batch-2.1</feature> -->

    <!-- Ops -->
    <!-- <feature>mpHealth-3.1</feature> -->
    <!-- <feature>mpMetrics-5.0</feature> -->
  </featureManager>
</server>

